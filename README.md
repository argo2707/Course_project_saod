# Использование заданных структур данных и алгоритмов при разработке программного обеспечения информационной системы

## Цель проекта

 Целью курсового проектирования является изучение структур данных и алгоритмов их обработки, а также получение практических навыков их использования при разработке программ.
## Задание на курсовой проект
 Разработать программное обеспечение информационной системы с использованием заданных структур данных и алгоритмов при разработке.
 
#### Вариант

*Предметная область* - Обслуживание читателей в библиотеке

*Метод хеширования* - Открытое хеширование

*Метода сортировки* - Подсчётом

*Вид списка* - Слоеный

*Метод обхода дерева* - Симметричный

*Алгоритм поиска слова в тексте* - Боуера и Мура

## Общие требования для заданной предметной области
1. Информационная система для предметной области «Обслуживание читателей в библиотеке» должна осуществлять ввод, хранение, обработку и вывод данных о:
  - Читателях;
  - Книгах;
  - Выдаче и приёме книг от читателей.
2. Данные о каждом читателе должны содержать:
-№ читательского билета – строка формата «ANNNN-YY», где A – буква, обозначающая права доступа читателя (А – только абонемент, Ч – только читальный зал, В – читальный зал и абонемент), NNNN – порядковый номер регистрации (цифры), YY – последние две цифры номера года регистрации;
  - ФИО – строка;
  - Год рождения – целое;
  - Адрес – строка;
  - Место работы/учёбы – строка;
  
	Примечание: длина строка (кроме № читательского билета) 	определяется студентом самостоятельно.
3. Данные о читателях должны быть организованны в виде хеш-таблицы, первичным ключом которой является «№ читательского билета». Метод хеширования определяется вариантом задания.
4. Данные о каждой книге должны содержать:
  - Шифр – строка формата «NNN.MMM», где NNN – номер тематического раздела (цифры), MMM – порядковый номер книги в разделе (цифры);
  - Автор(-ы) – строка;
  - Название – строка;
  - Издательство – строка;
  - Год издания – целое;
  - Количество экземпляров всего – целое;
  - Количество экземпляров в наличии – целое.
5. Данные о книгах должны быть организованны в виде АВЛ=дерева поиска, упорядоченного по «Шифру».
6. Данные о выдаче или приёме книг от читателей должны содержать:
  - № читательского билета – строка, формат которой соответствует аналогичной строке в данных о читателях;
  - Шифр – строка, формат которой соответствует аналогичной строке в данных о книгах;
  - Дата выдачи – строка;
  - Дата возврата – строка.
	Примечания:
	  - Наличие в этих данных записи, содержащей в поле «№ читательского билета» значение X и в поле «Шифр» значение Y означает выдачу читателю с номером читательского билета X экземпляра книги с шифром Y. Отсутствие такой записи означает, что читателю с номером читательского билета X не выдавался ни один экземпляр книги с шифром Y;
	  - Одному читателю может быть выдано несколько книг, и экземпляры одной книги могут быть выданы нескольким читателям. Таким образом, могут быть данные, имеющие повторяющиеся значения в своих полях.
7. Данные о выдаче или приёме книг от читателей должны быть организованны в виде списка, который упорядочен по первичному ключу – «Шифр». Вид списка и метод сортировки определяются вариантом задания.
8. Информационная система «Обслуживание читателей в библиотеке» должны осуществлять следующие операции:
  - Регистрация нового читателя;
  - Снятие с обслуживания читателя;
  - Просмотр всех зарегистрированных читателей;
  - Очистка данных о читателях;
  - Поиск читателя по № читательского билета. Результаты поиска – все сведения о найденном читателе и шифры книг, которые ему выданы;
  - Поиск читателя по ФИО. Результаты поиска – список найденных читателей с указанием № читательского билета и ФИО;
  - Добавление новой книги;
  - Удаление сведений о книге;
  - Просмотр всех имеющихся книг;
  - Очистка данных о книгах;
  - Поиск книги по шифру. Результаты поиска – все сведения о найденной книге, а также № читательских билетов и ФИО читателей, которым выданы экземпляры этой книги;
  - Поиск книги по фрагментам ФИО автора(-ов) или названия. Результаты поиска – список найденных книг с указанием шифра, автора(-ов), названия, издательства, года издания и количества экземпляров в наличии;
  - Регистрация выдачи экземпляра книги читателю;
  - Регистрация приёма экземпляра книги от читателя.
9. Состав данных о читателе или книге, выдаваемых при просмотре всех зарегистрированных читателей или просмотре всех имеющихся книг, определяются студентом самостоятельно, но должен содержать не менее двух полей.
10. Метод поиска читателя по ФИО определяется студентом самостоятельно. Выбранный метод необходимо сравнить с альтернативными методами.
11. Поиск книги по фрагментам ФИО автора(-ов) или названия должен осуществляться путем систематического обхода АВЛ-дерева поиска. Метод обхода определяется вариантом задания. При поиске книги по фрагментам ФИО автора(-ов) или названия могут быть заданы как полное ФИО автора(-ов) или названия так и их части (например, ФИО одного из нескольких авторов, одно слово или часть слова из названия). Для обнаружения заданного фрагмента в полном ФИО автора(-ов) или названии должен применяться алгоритм поиска слова в тексте, указанный в варианте задания.
12. Регистрация выдачи экземпляра книги читателю должна осуществляться только при наличии свободных экземпляров выдаваемой книги (значение поля «Количество экземпляров в наличии» для соответствующей книги больше нуля).
13. При регистрации выдачи экземпляра книги или приема экземпляра книги от читателя должно корректироваться значение поля «Количество экземпляров в наличии» для соответствующей книги.

## Алгоритмы и структуры данных
### Структуры данных
#### Хеш-таблица
Алгоритм хеш-функции:
````
int heshir(string keystri)
{
		int keyint = 0;
		keyint = ((int)keystri[7] * (int)keystri[2] + (int)keystri[0] * (int)keystri[3] +
			(int)keystri[3] * (int)keystri[4] + (int)keystri[1] * (int)keystri[5] +
			(int)keystri[3] * (int)keystri[5] + (int)keystri[6] * (int)keystri[2]+(int)keystri[5] * (int)keystri[0]) % myhesh.segm;
		return keyint;
}
````
Листинг остального кода хеш-таблицы приведён в полном листинге кода программы в [Source.cpp](https://github.com/argo2707/course_project_saod/blob/main/Source.cpp)

Для хранения записей о читателе библиотеки используется структура вида:
````
struct reader
{
	reader* pnext=NULL;
	string nombtick = ""; //номер билета
	string fio=""; //фио
	int yearbirt = 0; //год рождения
	string adres=""; //адрес 
	string place=""; // место работы/учебы
	string ciph[20];
};
````
где: 
	`string nombtick` – № читательского билета;
	`string fio` – ФИО читателя;
	`int yearbirt` – год рождения читателя;
	`string adres` – адрес проживания читателя;
	`string place` – место учёбы/работы читателя;
	`string ciph[20]` –шифр книг, которые читатель брал.

#### Бинарное дерево поиска (АВЛ-дерево)
Для хранения записей сведений о книгах библиотеки используется следующая структура, представляющая узлы АВЛ-дерева:
````
struct book
{
	string cipher; //шифр
	string author; //автор
	string title; //название
	string publicHouse; //издательство
	int yearpubl; //год издания
	int quantitotal; //кол-во всего
	int quantiavailab; //в наличии
	int height = 1; //высота узла АВЛ-дерева
	book* left = NULL;//указатель на левое поддерево
	book* right = NULL;//указатель на правое поддерево
};
````
где:
	`string cipher` – шифр книги;
	`string author` – имя автора книги;
	`string title` – название книги;
	`string publicHouse` – название издательства;
	`int yearpubl` – год издания книги;
	`int quantitotal` – всего книг;
	`int quantiavailab` – количество в наличии;
	`int height = 1` – высота узла АВЛ-дерева;
	`book* left = NULL` – указатель на левое поддерево;
	`book* right = NULL` – указатель на правое поддерево.
	Шифр книги преобразуется в целочисленное значения ключа узла АВЛ-дерева с помощью следующего алгоритма:
````
int convertBookCode(string bookCode) {
	string result;
	result = bookCode.substr(0, 3) + bookCode.substr(4, 3);
	return stoi(result);
}
````
Листинг кода АВЛ-дерева приведён в полном листинге кода программы в [Source.cpp](https://github.com/argo2707/course_project_saod/blob/main/Source.cpp).

#### Слоеный список
Идея, лежащая в основе слоёных списков, очень напоминает метод, используемый при поиске имен в адресной книжке. Чтобы найти имя, вы помечаете буквой страницу, откуда начинаются имена, начинающиеся с этой буквы. На рис. 1, например, самый верхний список представляет обычный односвязный список. Добавив один "уровень" ссылок, мы ускорим поиск. Сначала мы идем по ссылкам уровня 1, затем, когда дойдем до нужного отрезка списка, пойдем по ссылкам нулевого уровня. 

![image](https://user-images.githubusercontent.com/79849850/233803288-2feb7fa5-ba5c-4c60-9881-d10994c7c607.png)

Рис. 1 – Слоеный список.

Для хранения записей о выдаче и приёме книг в списке используется структура вида:
````
struct issrec
{
	string nombtick;
	string cipher;
	string dateis="";
	string dateret="";
	issrec* pnext1=NULL;
	issrec* pnext3 = NULL;
};
````
где:
	`string nombtick` – № существующего в системе читательского билета;
	`string cipher` – существующий в системе шифр книги;
	`string dateis = “”` – дата выдачи книги формата «DD.MM.YYYY»;
	`string dateret = “”` – дата возврата книги формата «DD.MM.YYYY»;
	`issrec* next3 = NULL` – указатель на следующий элемент списка.
	`issrec* next1 = NULL` – указатель на элемент списка, у которого 3 символ шифра отличается.
  
Листинг кода слоеного списка приведён в полном листинге кода программы в [Source.cpp](https://github.com/argo2707/course_project_saod/blob/main/Source.cpp).

#### Алгоритмы
Алгоритм Боуера и Мура при поиске по фрагменту слова в тексте

Сложность: O(n+m), где n – длина строки, в которой выполняется поиск, m – длина шаблона поиска.

Код алгоритма:
````
bool searchWord(string source, string find)
{
	int sourceLen = source.size();
	int templateLen = find.size();
	if (templateLen > sourceLen) {
		return false;
	}
	std::map<char, int> offsetTable;
	for (int i = 0; i < templateLen - 1; i++) {
		offsetTable.insert(std::pair<char, int>(static_cast<char>(find[i]), templateLen - i - 1));
	}
	for (int i = 0; i <= 255; i++) {
		offsetTable.insert(std::make_pair(static_cast<char>(i), templateLen));
	}
	int i = templateLen - 1;
	int j = i;
	int k = i;
	while (j >= 0 && i <= sourceLen - 1) {
		j = templateLen - 1;
		k = i;
		while (j >= 0 && source[k] == find[j]) {
			k--;
			j--;
		}
		i += offsetTable.at(source[i]);
	}
	if (k >= sourceLen - templateLen) {
		return false;
	}
	else {
		return true;
	}
}
````
#### Открытое хеширование
Принцип организации хеш-таблицы методом открытого хеширования заключается в реализации логически связанных цепочек, начинающихся в ячейках хеш-таблицы. Под цепочками подразумеваются связанные списки, указатели на которые хранятся в ячейках хеш-таблицы:
  
![image](https://user-images.githubusercontent.com/79849850/233803435-4c753288-d1e0-4cc6-885e-27574ed3416c.png)

Рис. 2 – Открытое хеширование

На рисунке 2 изображены связанные списки со ссылающейся на них хеш-таблицей (ее размер = M). Первый столбец таблицы содержит хешированные значения ключей, второй – ссылки на списки. Количество последних ограничено лишь числом элементов исходного массива (он не показан, но предполагается). Состоят списки из трех (последний элемент подсписка – из двух) полей: & — адрес элемента списка, $ — данные, * — указатель (ссылка). 

Код алгоритма открытого хеширования интегрирован в функцию добавления, поиска, удаления, потому будет приведён пример функции добавления с выделением «маркера» самого алгоритма:
````
void addread(){
		reader* tempi;
		reader* tempread;
		tempi = new reader;
		tempread = tempi;
		tempi->add(myhesh.key);
		myhesh.key += 1;
		int tempint = heshir(tempi->nombtick);
		if (myhesh.heshtable[tempint] == NULL){
			myhesh.heshtable[tempint] = tempi;
		}
		else{
			if(myhesh.heshtable[tempint]->pnext==nullptr)
				myhesh.heshtable[tempint]->pnext = tempi;
			else{
				tempread = myhesh.heshtable[tempint];
				do{
					tempread = tempread->pnext;
					if (tempread->pnext == nullptr){
						tempread->pnext = tempi;
						break;
					}
				} while (tempread->pnext != nullptr);
			}
		}
		for (int i = 0; i < myhesh.segm; i++){
			if (myhesh.heshtable[i] == NULL)
				cout << "[" << i << "]" << " - " << endl;
			else
				if (myhesh.heshtable[i]->pnext == NULL)
					cout << "[" << i << "]" << " - " << myhesh.heshtable[i]->nombtick << endl;
				else{
					tempi = myhesh.heshtable[i];
					cout << "[" << i << "]" << " - " <<tempi->nombtick;
					do{
						tempi = tempi->pnext;
						cout << " -> " << tempi->nombtick;
						
					} while (tempi->pnext != NULL);
					cout << endl;
				}
		}
		cout << "1 - Вернуться в меню\n";
		cout << "2 - Добавить ещё\n";
		int temp;
		cin >> temp;
		switch (temp){
		case 1:
			system("cls");
			menu();
			break;
		case 2:
			system("cls");
			addread();
			break;
		default:
			system("cls");
			cout << "1 - Вернуться в меню\n";
			cout << "2 - Добавить ещё\n";
			int temp;
			cin >> temp;
			switch (temp){
			case 1:
				system("cls");
				menu();
				break;
			case 2:
				system("cls");
				addread();
				break;
			default:
				system("cls");
				break;
			}
			break;
		}
}
````
#### Сортировка подсчётом
Сложность: O(n^2)

Идея алгоритма заключается в следующем: считаем количество вхождений каждого элемента массива; исходя из данных, полученных на первом шаге, формируем отсортированный массив.

Код алгоритма сортировки слоеного списка:
````
issrec* sorting(issrec* p)
{
	string nombtick;
	string cipher;
	string dateis = "";
	string dateret = "";
	int k=0,i=0,j;
	if (p == NULL) {return 0;}
	issrec* temp;
	issrec* tempi;
	issrec* tempi2=p;
	while(tempi2!= NULL){
		temp = p;
		k = 0;
		while (temp!= NULL){
			j = 0;
			if ((p->cipher[2] < temp->cipher[2]) || (p->cipher[2] == temp->cipher[2])&&(j<i))
				k++;
			j++;
			temp = temp->pnext3;
		}
		tempi = p;
		while (tempi != NULL){
			j = 0;
			if (k == j){
				nombtick = tempi->nombtick;
				cipher = tempi->cipher;
				dateis = tempi->dateis;
				dateret = tempi->dateret;
				tempi->cipher = p->cipher;
				tempi->dateis = p->dateis;
				tempi->dateret = p->dateret;
				tempi->nombtick = p->nombtick;
				p->cipher = cipher;
				p->dateis=dateis;
				p->dateret=dateret;
				p->nombtick=nombtick;
				break;
			}
			j++;
			tempi = tempi->pnext3;
		}
		i++;
		tempi2 = tempi2->pnext3;
	}
	tempi2 = p;
	temp = p;
	while (tempi2->pnext3 != NULL){
		if ((tempi2->cipher[2]) != ((tempi2->pnext3)->cipher[2])){
			temp->pnext1 = tempi2->pnext3;
			temp = tempi2->pnext3;
		}
		tempi2 = tempi2->pnext3;
	}
	return p;
}
````
#### Симметричный метод обхода дерева
Порядок обхода узлов дерева (вызов узлов пронумерован) изображён на следующем изображении:
![image](https://user-images.githubusercontent.com/79849850/233803582-3c04a6ee-78bf-46d5-87cb-7eb2f50ba801.png)

Рис. 4 – Симметричный обход двоичного дерева.
Код алгоритма на примере функции вывода дерева:
````
void printTree(book * root) 
{
	if (root == NULL)
		return;
	if (root != NULL) {
		printTree(root->left);
		cout << root->title << endl;
		cout << "   Автор: " << root->author << endl;
		cout << "   Шифр книги: " << root->cipher << endl;
		cout << "   Издатель: " << root->publicHouse << endl;
		cout << "   Год издания: " << root->yearpubl << endl;
		cout << "   Всего: " << root->quantitotal << endl;
		cout << "   В наличии: " << root->quantiavailab << endl << endl;
		printTree(root->right);

	}
}
````
## Описание программы
Программа «Обслуживание читателей в библиотеке» реализует весь функционал. Программа написана на языке C++ в виде консольного приложения и работает на любых современных ПК. Дополнительных устройств для функционирования программы не требуется. Программа написана в среде Visual Studio 2019.

Информация о читателях представлена в виде хеш-таблицы; сведения о книгах в виде АВЛ-дерева, а записи выдачи и приёма книг читателю в виде слоеного списка с сортировкой по шифру книги.

После запуска программы открывается главное окно, которое содержит навигацию в виде меню (рис. 5). Выбор осуществляется с помощью ввода номера пункта меню и подтверждением ввода с помощью нажатия «Enter».
 ![image](https://user-images.githubusercontent.com/79849850/233803620-5520098a-f865-444a-b076-b4c8ab5ac612.png)

Рис. 5 – Главное меню программы

Полный листинг кода программы приведён в [Source.cpp](https://github.com/argo2707/course_project_saod/blob/main/Source.cpp)
.
